================================================ GO MICROSERVICES =====================================

Tools:

1. Make
Website: https://www.gnu.org/software/make/
Install Chocolatey: Set-ExecutionPolicy Bypass -Scope Process -Force; `
                      iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
Install Make: choco install make
Check: make --version

2. Docker
Tu build images and run them as containers.
Website: https://www.docker.com/
Install : https://docs.docker.com/desktop/install/windows-install/
Check: docker --version

============================================== COMMANDS =============================================

go mod init - initializes new module in current directory

# Install go-chi:
Chi is a lightweight, idiomatic and composable router for building Go HTTP services.
Website: https://github.com/go-chi/chi
Install:
go get github.com/go-chi/chi/v5
go get github.com/go-chi/chi/v5/middleware
go get github.com/go-chi/cors

Gorilla Web toolkit can be used also (https://www.gorillatoolkit.org/), or other 3rd party libraries.


# Install Postgres Library
go get github.com/jackc/pgconn
go get github.com/jackc/pgx/v4
go get github.com/jackc/pgx/v4/stdlib



=========================== LISTENER SERVICE (AMQP with RabbitMQ) ===================================
Sources:
 - AMQP 0-9-1 Model: https://www.rabbitmq.com/tutorials/amqp-concepts.html
 - https://hevodata.com/learn/rabbitmq-exchange-type/

Until now the way that these microservices communicate with each other is either by having the broker
receive a request, send it off to a microservice and get the response back, or directly for example
with the authentication microservice. Listener Service is going to be added, this service will talk
with RabbitMQ, which is a server that actually manages queues.

For example: If someone wants to authenticate, it will send a request to the broker service and then
the broker service won't communicate directly with the Authentication Service, instead it will push
instruction to the RabbitMQ, RabbitMQ will put that instruction into the queue and the Listener Service
will look at the queue, it will pull out all instructions that are in the queue, and then it will
decide which Service to call to handle that request.

# Install RabbitMQ driver
go get github.com/rabbitmq/amqp091-go

Use docker hub to see the available images for RabbitMQ

***
amqp.Dial(amqp://username:password@host")
First to try to connect with rabbit mq locally we can leave the host as "localhost"
but once we containerize this and make it part of our docker compose file, that is
going to change to whatever we called rabbit mq in docker compose.
So amqp.Dial(amqp://guest:guest@localhost") is going to change to amqp.Dial(amqp://guest:guest@rabbitmq")
